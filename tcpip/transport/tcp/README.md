# TCP 协议

## tcp特点
1. tcp 是面向连接的传输协议。
2. tcp 的连接是端到端的。
3. tcp 提供可靠的传输。
4. tcp 的传输以字节流的方式。
5. tcp 提供全双工的通信。
6. tcp 有拥塞控制。

![img](https://doc.shiyanlou.com/document-uid949121labid10418timestamp1555573949562.png)

``` sh
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|          Source Port          |       Destination Port        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                        Sequence Number                        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Acknowledgment Number                      |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|  Data |           |U|A|P|R|S|F|                               |
| Offset| Reserved  |R|C|S|S|Y|I|            Window             |
|       |           |G|K|H|T|N|N|                               |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|           Checksum            |         Urgent Pointer        |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                    Options                    |    Padding    |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|                             data                              |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

1. 源端口和目的端口 各占 2 个字节，分别 tcp 连接的源端口和目的端口。关于端口的概念之前已经介绍过了。
2. 序号 占 4 字节，序号范围是[0，2^32 - 1]，共 2^32（即 4294967296）个序号。序号增加到 2^32-1 后，下一个序号就又回到 0。TCP 是面向字节流的，在一个 TCP 连接中传送的字节流中的每一个字节都按顺序编号。整个要传送的字节流的起始序号（ISN）必须在连接建立时设置。首部中的序号字段值则是指的是本报文段所发送的数据的第一个字节的序号。例如，一报文段的序号是 301，而接待的数据共有 100 字节。这就表明：本报文段的数据的第一个字节的序号是 301，最后一个字节的序号是 400。显然，下一个报文段（如果还有的话）的数据序号应当从 401 开始，即下一个报文段的序号字段值应为 401。
3. 确认号 占 4 字节，是期望收到对方下一个报文段的第一个数据字节的序号。例如，B 正确收到了 A 发送过来的一个报文段，其序号字段值是 501，而数据长度是 200 字节（序号 501~700），这表明 B 正确收到了 A 发送的到序号 700 为止的数据。因此，B 期望收到 A 的下一个数据序号是 701，于是 B 在发送给 A 的确认报文段中把确认号置为 701。注意，现在确认号不是 501，也不是 700，而是 701。 总之：若确认号为 N，则表明：到序号 N-1 为止的所有数据都已正确收到。TCP 除了第一个 SYN 报文之外，所有 TCP 报文都需要携带 ACK 状态位。
4. 数据偏移 占 4 位，它指出 TCP 报文段的数据起始处距离 TCP 报文段的起始处有多远。这个字段实际上是指出 TCP 报文段的首部长度。由于首部中还有长度不确定的选项字段，因此数据偏移字段是必要的，但应注意，“数据偏移”的单位是 4 个字节，由于 4 位二进制数能表示的最大十进制数字是 15，因此数据偏移的最大值是 60 字节。
5. 保留 占 6 位，保留为今后使用，但目前应置为 0。
6. 控制报文标志
    - **紧急URG（URGent）** 当 URG=1 时，表明紧急指针字段有效。它告诉系统此报文段中有紧急数据，应尽快发送（相当于高优先级的数据），而不要按原来的排队顺序来传送。例如，已经发送了很长的一个程序要在远地的主机上运行。但后来发现了一些问题，需要取消该程序的运行，因此用户从键盘发出中断命令。如果不使用紧急数据，那么这两个字符将存储在接收 TCP 的缓存末尾。只有在所有的数据被处理完毕后这两个字符才被交付接收方的应用进程。这样做就浪费了很多时间。 当 URG 置为 1 时，发送应用进程就告诉发送方的 TCP 有紧急数据要传送。于是发送方 TCP 就把紧急数据插入到本报文段数据的最前面，而在紧急数据后面的数据仍然是普通数据。这时要与首部中紧急指针（Urgent Pointer）字段配合使用。
    - **确认ACK（ACKnowledgment）** 仅当 ACK=1 时确认号字段才有效，当 ACK=0 时确认号无效。TCP 规定，在连接建立后所有的传送的报文段都必须把 ACK 置为 1。
    - **推送 PSH（PuSH）** 当两个应用进程进行交互式的通信时，有时在一端的应用进程希望在键入一个命令后立即就能收到对方的响应。在这种情况下，TCP 就可以使用推送（push）操作。这时，发送方 TCP 把 PSH 置为 1，并立即创建一个报文段发送出去。接收方 TCP 收到 PSH=1 的报文段，就尽快地交付接收应用进程。
    - **复位RST（ReSeT）** 当 RST=1 时，表名 TCP 连接中出现了严重错误（如由于主机崩溃或其他原因），必须释放连接，然后再重新建立传输连接。RST 置为 1 用来拒绝一个非法的报文段或拒绝打开一个连接。
    - **同步SYN（SYNchronization）** 在连接建立时用来同步序号。当 SYN=1 而 ACK=0 时，表明这是一个连接请求报文段。对方若同意建立连接，则应在响应的报文段中使 SYN=1 和 ACK=1，因此 SYN 置为 1 就表示这是一个连接请求或连接接受报文。
    - **终止FIN（FINis，意思是“完”“终”）** 用来释放一个连接。当 FIN=1 时，表明此报文段的发送发的数据已发送完毕，并要求释放运输连接。
7. 窗口 占 2 字节，窗口值是[0，2^16-1]之间的整数。窗口指的是发送本报文段的一方的接受窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文段首部中的确认号算起，接收方目前允许对方发送的数据量（以字节为单位）。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。总之，窗口值作为接收方让发送方设置其发送窗口的依据，作为流量控制的依据，后面会详细介绍。 总之：窗口字段明确指出了现在允许对方发送的数据量。窗口值经常在动态变化。
8. 检验和 占 2 字节，检验和字段检验的范围包括首部和数据这两部分。和 UDP 用户数据报一样，在计算检验和时，要在 TCP 报文段的前面加上 12 字节的伪首部。伪首部的格式和 UDP 用户数据报的伪首部一样。但应把伪首部第 4 个字段中的 17 改为 6（TCP 的协议号是 6）；把第 5 字段中的 UDP 中的长度改为 TCP 长度。接收方收到此报文段后，仍要加上这个伪首部来计算检验和。若使用 IPv6，则相应的伪首部也要改变。
9. 紧急指针 占 2 字节，紧急指针仅在 URG=1 时才有意义，它指出本报文段中的紧急数据的字节数（紧急数据结束后就是普通数据) 。因此，在紧急指针指出了紧急数据的末尾在报文段中的位置。当所有紧急数据都处理完时，TCP 就告诉应用程序恢复到正常操作。值得注意的是，即使窗口为 0 时也可以发送紧急数据。
10. 选项 选项长度可变，最长可达 40 字节。当没有使用“选项”时，TCP 的首部长度是 20 字节。TCP 首部总长度由 TCP 头中的“数据偏移”字段决定，前面说了，最长偏移为 60 字节。那么“tcp 选项”的长度最大为 60-20=40 字节。

## tcp选项

TCP 最初只规定了一种选项，即最大报文段长度 MSS（Maximum Segment Szie）。后来又增加了几个选项如窗口扩大选项、时间戳选项等，下面说明常用的选项。

1. kind=0 是选项表结束选项。

2. kind=1 是空操作（nop）选项

    没有特殊含义，一般用于将 TCP 选项的总长度填充为 4 字节的整数倍，为啥需要 4 字节整数倍？因为前面讲了数据偏移字段的单位是 4 个字节。

3. kind=2 是最大报文段长度选项
    TCP 连接初始化时，通信双方使用该选项来协商最大报文段长度（Max Segment Size，MSS）。TCP 模块通常将 MSS 设置为（MTU-40）字节（减掉的这 40 字节包括 20 字节的 TCP 头部和 20 字节的 IP 头部）。这样携带 TCP 报文段的 IP 数据报的长度就不会超过 MTU（假设 TCP 头部和 IP 头部都不包含选项字段，并且这也是一般情况），从而避免本机发生 IP 分片。对以太网而言，MSS 值是 1460（1500-40）字节。

4. kind=3 是窗口扩大因子选项
    TCP 连接初始化时，通信双方使用该选项来协商接收通告窗口的扩大因子。在 TCP 的头部中，接收通告窗口大小是用 16 位表示的，故最大为 65535 字节，但实际上 TCP 模块允许的接收通告窗口大小远不止这个数（为了提高 TCP 通信的吞吐量）。窗口扩大因子解决了这个问题。假设 TCP 头部中的接收通告窗口大小是 N，窗口扩大因子（移位数）是 M，那么 TCP 报文段的实际接收通告窗口大小是 N 乘 2M，或者说 N 左移 M 位。注意，M 的取值范围是 0 ～ 14。

    和 MSS 选项一样，窗口扩大因子选项只能出现在同步报文段中，否则将被忽略。但同步报文段本身不执行窗口扩大操作，即同步报文段头部的接收通告窗口大小就是该 TCP 报文段的实际接收通告窗口大小。当连接建立好之后，每个数据传输方向的窗口扩大因子就固定不变了。关于窗口扩大因子选项的细节，可参考标准文档 RFC 1323。

5. kind=4 是选择性确认（Selective Acknowledgment，SACK）选项
    TCP 通信时，如果某个 TCP 报文段丢失，则 TCP 模块会重传最后被确认的 TCP 报文段后续的所有报文段，这样原先已经正确传输的 TCP 报文段也可能重复发送，从而降低了 TCP 性能。SACK 技术正是为改善这种情况而产生的，它使 TCP 模块只重新发送丢失的 TCP 报文段，不用发送所有未被确认的 TCP 报文段。选择性确认选项用在连接初始化时，表示是否支持 SACK 技术。

6. kind=5 是 SACK 实际工作的选项
    该选项的参数告诉发送方本端已经收到并缓存的不连续的数据块，从而让发送端可以据此检查并重发丢失的数据块。每个块边沿（edge of block）参数包含一个 4 字节的序号。其中块左边沿表示不连续块的第一个数据的序号，而块右边沿则表示不连续块的最后一个数据的序号的下一个序号。这样一对参数（块左边沿和块右边沿）之间的数据是没有收到的。因为一个块信息占用 8 字节，所以 TCP 头部选项中实际上最多可以包含 4 个这样的不连续数据块（考虑选项类型和长度占用的 2 字节）。

7. kind=8 是时间戳选项
    该选项提供了较为准确的计算通信双方之间的回路时间（Round Trip Time，RTT）的方法，从而为 TCP 流量控制提供重要信息。

## tcp连接的建立

![img](https://doc.shiyanlou.com/document-uid949121labid10418timestamp1555574034117.png)

上面的图片显示了 tcp 的三次握手，但只是简单的降了三次报文的交互，下面讲讲详细的三次握手。先讲三次握手的正常情况，接着我们再讲异常情况。

### 正常情况（没有丢包）

主机 A 的 TCP 向主机 B 的 TCP 发出连接请求，发送 syn 报文段在发送 syn 之前，设置握手状态为 SynSent，还需要做一些准备工作，包括：随机生成 ISN1、计算 MSS、计算接收窗口扩展因子、是否开启 sack。 根据这些参数生成 syn 报文的选项参数，附在 tcp 选项中，然后发送带着这些选项的 syn 报文。

主机 B 的 TCP 收到连接请求 syn 报文段后，需要回复 syn+ack 报文因为 tcp 的控制报文需要消耗一个字节的序列号，所以回复的 ack 序列号为 ISN1+1，设置接收窗口，设置握手状态为 SynRcvd，并随机生成 ISN2、计算 MSS、计算接收窗口扩展因子、是否开启 sack。根据这些参数生成 syn+ack 报文的选项参数，附在 tcp 选项中，回复给主机 A。

主机 A 的 TCP 收到 syn+ack 报文段后，还要向 B 回复确认和上面一样，tcp 的控制报文需要消耗一个字节的序列号，所以回复的 ack 序列号为 ISN2+1，发送 ack 报文给主机 B。

主机 A 的 TCP 通知上层应用进程，连接已经建立，可以发送数据了，当主机 B 的 TCP 收到主机 A 的确认后，也通知上层应用进程，连接建立。

### 异常情况（有丢包）

主机 A 发给主机 B 的 SYN 中途丢失，没有到达主机 B 因为在发送 syn 之前，就设置了超时定时器，如果在一定的时间内没收到回复，就会触发重传，所以主机 A 会周期性超时重传，直到收到主机 B 的确认。重传的周期，一开始默认 1s，每重传一次，变为原来的 2 倍，如果重传周期超过 1 分钟，返回错误，不再尝试重连。

主机 B 发给主机 A 的 SYN +ACK 中途丢失，没有到达主机 A 主机 B 会周期性超时重传，直到收到主机 A 的确认，重传的策略和 syn 报文一样，每重传一次，周期变为原来的 2 倍。

主机 A 发给主机 B 的 ACK 中途被丢，没有到达主机 B 主机 A 发完 ACK，单方面认为 TCP 为 Established 状态，而 B 显然认为 TCP 为 Active 状态：

a. 如果此时双方都没有数据发送，主机 B 会周期性超时重传，直到收到 A 的确认，收到之后主机 B 的 TCP 连接也为 Established 状态，双向可以发包。
b. 如果此时 A 有数据发送，主机 B 收到主机 A 的 Data + ACK，自然会切换为 established 状态，并接受主机 A 的 Data。

## TCP连接的释放

![img](https://doc.shiyanlou.com/document-uid949121labid10418timestamp1555574060171.png)

1）数据传输结束后，主机 A 的应用进程调用 Close 函数，先向其 TCP 发出释放连接请求，不再发送数据。TCP 通知对方要释放从主机 A 到主机 B 的连接，将发往主机 B 的 TCP 报文段首部的终止比特 FIN 置为 1，序号 seq1 等于已传送数据的最后一个字节的序号加 1。

2）主机 B 的 TCP 收到释放连接通知后发出确认，其序号为 seq1+1，同时通知应用进程，这样主机 A 到主机 B 的连接就释放了，连接处于半关闭状态。主机 B 不在接受主机 A 发来的数据；但主机 B 还向 A 发送数据，主机 A 若正确接收数据仍需要发送确认。

3）在主机 B 向主机 A 的数据发送结束后，其应用进程应该主动调用 Close 函数，释放 TCP 连接。主机 B 发出的连接释放报文段必须将终止比特置为 1，并使其序号 seq2 等于前面已经传送过的数据的最后一个字节的序号加 1，还必须回复 ACK=seq1+1。

4）主机 A 对主机 B 的连接释放报文段发出确认，将 ACK 置为 1，ACK=seq2+1, seq=seq1+1。这样才把从 B 到 A 的反方向连接释放掉，主机 A 的 TCP 再向其应用进程报告，整个连接已经全部释放。

还有一个要注意的是，fin 包和数据包一样，如果丢失了，会进行重传，实际上可能是是 fin 丢失或 ack 丢失。重传的周期由 rto 决定。